#!/usr/bin/env ruby

require "net/https"
require "uri"

# Place this file in ~/.git_template/hooks/post-commit
# Point git to the template directory to import the hook on a git init
#   git config --global init.templatedir '~/.git_template'

# taken from http://stackoverflow.com/a/1320011/818073
def shellescape(str)
    # An empty argument will be skipped, so return empty quotes.
    return "''" if str.empty?

    str = str.dup

    # Process as a single byte sequence because not all shell
    # implementations are multibyte aware.
    str.gsub!(/([^A-Za-z0-9_\-.,:\/@\n])/n, "\\\\\\1")

    # A LF cannot be escaped with a backslash because a backslash + LF
    # combo is regarded as line continuation and simply ignored.
    str.gsub!(/\n/, "'\n'")

    str
end

def snap_picture(file)
  puts "Making gitshot #{file}!"
  output = `imagesnap -q -w 2.5 #{file}`
  puts output
end

def create_file_path
  repo_name=`basename "$(git rev-parse --show-toplevel)"`
  repo_name.chomp!

  home_dir=ENV['HOME']
  git_shots_dir = ENV['GITSHOTS_DIR'] || "#{home_dir}/.gitshots"

  Dir.mkdir(git_shots_dir) unless Dir.exists?(git_shots_dir)

  shellescape("#{git_shots_dir}/#{Time.now.to_i}_#{repo_name}.jpg")
end

def update_slack_avatar(token, file, crop_width = nil, crop_x = nil, crop_y = nil)
  uri = URI.parse('https://slack.com/api/users.setPhoto')

  boundary = 'AaB03x'
  post_body = MultipartBody.new('AaB03x')

  unless crop_width.nil?
    post_body.add_part(MultipartBodyPart.new('crop_w', crop_width))
  end

  unless crop_x.nil?
    post_body.add_part(MultipartBodyPart.new('crop_x', crop_x))
  end

  unless crop_y.nil?
    post_body.add_part(MultipartBodyPart.new('crop_y', crop_y))
  end

  post_body.add_part(MultipartBodyPart.new('token', token))
  post_body.add_part(MultipartBodyPart.new('image', File.new(file, 'r'), 'image/jpeg'))

  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = true
  request = Net::HTTP::Post.new(uri.request_uri)
  request.body = post_body.render
  request['Content-Type'] = "multipart/form-data, boundary=#{boundary}"

  response = http.request(request)

  puts response.body
end

class MultipartBody
  def initialize(boundary, parts = [])
    @parts = parts
    @boundary = boundary
  end

  def add_part(part)
    @parts.push(part)
  end

  def build
    body_parts = @parts.reduce([]) do |all, part|
      enclosed_part = ["--#{@boundary}"].concat(part.build)
      all.concat(enclosed_part)
    end
    body_parts.push("--#{@boundary}--")
  end

  def render
    build.join("\n")
  end
end

class MultipartBodyPart
  def initialize(name, value, content_type = 'text/plain')
    @name = name
    @value = value
    @content_type = content_type
  end

  def build
    body_part = []
    body_part << "Content-Disposition: form-data; name=\"#{@name}\"#{"; filename=\"#{File.basename(@value.path)}\"" if @value.is_a? File}"
    body_part << "Content-Type: #{@content_type}"
    body_part << ''
    body_part <<
        if @value.is_a? File
          @value.read
        else
          @value
        end
  end
end

unless File.directory?(File.expand_path('../../rebase-merge', __FILE__))
  file = create_file_path
  snap_picture(file)

  token = ENV['SLACK_USER_API_TOKEN']
  unless token.to_s.empty?
    width = 720
    x_position = 320
    update_slack_avatar(token, file, width, x_position)
  end
end

